## Fetch vs XmlHttpRequest
`fetch()` unlike `xmlHttpRequest()`:
* Uses promise
* Is simple to use
* Full access to featires (verb, headers ...)
* Utilities for parsing formats, so the content can easily be parsed as JSON, text, blob ...

## `async/await`
`async/await` allows you to write asynchronous code based on Promises, in a manner that allows you to reuse your synchronous code writing skills. By doing this, we can write code that is far cleaner and more understandable than our chained promise example.

> In short: Async and Await is just a Syntactic Sugar For Promises. [More](https://medium.com/@matt.mcalister93/async-and-await-syntactic-sugar-for-promises-in-javascript-aee7ace36d14)

An `async` function always returns a Promise. The Promise resolves to value that is returned by the function.

Asynchronous functions can use the `await` operator in their bodies. The `await` operator can be attached to any variable. If that variable is not a Promise, the value returned for the `await` operator is the same as the variable.

But if the variable is a Promise, then the execution of the function is paused untill it is clear whether the Promise is going to be resolved or rejected.

If the Promise resolves, the value of the `await` operator is the resolved value of Promise, and if the variable is a promise that gets rejected, the `await` operator throws an error in the body of the `async` function which we can catch with `try/catch` constructs.

```javascript
async function myFirstAsyncFunction() {
  try {
    const fulfilledValue = await promise;
  }
  catch (rejectedValue) {
    // …
  }
}
```

### `for-await-of`
`for-await-of` automatically awaits any Promises generated by this iterator. `for-await-of` requires a runtime polyfill called the `asyncIterator` to work correctly.

```javascript
async function* numbers() {
  let index = 1;
  while(true) {
    yield index;
    index = await external(index);
    if (index > 10) {
      break;
    }
  }
}

async function gilad() {
  for await (const num of numbers()) {
    console.log(num);
  }
}
```

### Careful! Avoid going too sequential
Although you're writing code that looks synchronous, ensure you don't miss the opportunity to do things in parallel.

Say we wanted to fetch a series URLs and log them as soon as possible, in the correct order.
```javascript
function logInOrder(urls) {
  // fetch all the URLs
  const textPromises = urls.map(url => {
    return fetch(url).then(response => response.text());
  });

  // log them in order
  textPromises.reduce((chain, textPromise) => {
    return chain.then(() => textPromise)
      .then(text => console.log(text));
  }, Promise.resolve());
}
```

However, when converting the above to an async function, it's tempting to go too sequential:
```javascript
async function logInOrder(urls) {
  for (const url of urls) {
    const response = await fetch(url);
    console.log(await response.text());
  }
}
```

Looks much neater, but my second fetch doesn't begin until my first fetch has been fully read, and so on. This is much slower than the promises example that performs the fetches in parallel. Thankfully there's an ideal middle-ground:
```javascript
async function logInOrder(urls) {
  // fetch all the URLs in parallel
  const textPromises = urls.map(async url => {
    const response = await fetch(url);
    return response.text();
  });

  // log them in sequence
  for (const textPromise of textPromises) {
    console.log(await textPromise);
  }
}
```

In this example, the URLs are fetched and read in parallel, but the "smart" `reduce` bit is replaced with a standard, boring, readable for-loop.

### Browser support & workarounds
If you're targeting browsers that support generators you can polyfill async functions.

[Babel](http://babeljs.io/docs/plugins/preset-es2017/) will do this for you.

I recommend the transpiling approach, because you can just turn it off once your target browsers support async functions, but if you really don't want to use a transpiler, you can take [Babel's polyfill](https://gist.github.com/jakearchibald/edbc78f73f7df4f7f3182b3c7e522d25) and use it yourself. Instead of:
```javascript
async function slowEcho(val) {
  await wait(1000);
  return val;
}
```
…you'd include the polyfill and write:
```javascript
const slowEcho = createAsyncFunction(function*(val) {
  yield wait(1000);
  return val;
});
```

> Note that you have to pass a generator (`function*`) to `createAsyncFunction`, and use `yield` instead of `await`. Other than that it works the same.

#### [`Promise` vs. `async/await` article](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9)
